MFC中可能将相关模块信息存储于某种地方 



EXTERN_THREAD_LOCAL(_AFX_THREAD_STATE, _afxThreadState)
THREAD_LOCAL(_AFX_THREAD_STATE, _afxThreadState)

 AFX_COMDAT CThreadLocal<class_name> ident_name;
 __declspec( selectany ) CThreadLocal<_AFX_THREAD_STATE> _afxThreadState;

 selectany 类似于合并同一变量的多重定义，或者说 选取真实有效的一个定义
 selectany can be used in initializing global data defined by headers, when the same header appears in more than one source file.



template<class TYPE> 
class CThreadLocal 
可视为 CThreadLocalObject 的 包装辅助类。 
1.通过模板用于扩展适用于任何数据类型（CNoTrackObject 继承体系）。
2.提供动态创建对象的静态函数。



CThreadLocalObject

int m_nSlot;
设计上，应该对应到一个 CNoTrackObject 资源 （CNoTrackObject* ）

CNoTrackObject* GetData(CNoTrackObject* (AFXAPI* pfnCreateObject)());
根据 m_nSlot 进行相应操作：（涉及分配 slot ，新建 资源对象）
1.m_nSlot 为零 说明为新的资源对象 需要分配一个slot 来存储 （新建资源时）。
2.m_nSlot 不为零 ：
2.1.相应 slot 中， 无资源对象 ，将新建指定资源对象存储于其中，并返回新资源对象。
2.2.相应 slot 中， 有资源对象 ，返回该资源对象。

CNoTrackObject* GetDataNA();
仅简单返回 m_nSlot 中的的资源对象。（可能为 NULL ，无资源对象）




BYTE __afxThreadData[sizeof(CThreadSlotData)];
CThreadSlotData* _afxThreadData;
_afxThreadData = new(__afxThreadData) CThreadSlotData;
全局对象, new replacement 表达式创建： void* operator new(size_t, void* p) 。重载new 指定替换内存。

CThreadSlotData* _afxThreadData;  就是 CThreadLocalObject 操作的 slot 存储区


CThreadSlotData 存储数据

int CThreadSlotData::AllocSlot()
动态分配一块内存 （视作数组） （未初始化） （默认首次32个）
置零
循环递增取余下的空元素使用 （置标识位为1）
取完（全满），重新分配一块更大的内存 （包含之前的内容，不变） （32个元素递增） 
递增的部分，置零
循环递增取余下的空元素使用 （置标识位为1）
（全满）......

void CThreadSlotData::SetValue(int nSlot, void* pValue)
根据 线程本地存储索引，获取 存储空间对象 （m_tlsIndex、CThreadData*）
存储空间对象 不存在，分配存储空间对象 （new CThreadData;） （重载new 0初始化分配空间）
存储空间对象 合入链表中 （m_list.AddHead(pData);）
（递增）分配内存区块 （视作数组）（LocalAlloc、LocalReAlloc） （测试来看基本上每次都要重新递增分配）
存储空间对象 关联 内存区块
（递增）内存区块 置零
存储空间对象 更新到最新的 空间大小 (刚好是最新的nSlot+1个)
存储空间对象 存储到 线程本地存储索引 的位置 （m_tlsIndex、CThreadData*）
存储空间对象 的 内存区块 中取指定 的元素空间 存储 资源 （nSlot, pValue）

inline void* CThreadSlotData::GetThreadValue(int nSlot)
根据 线程本地存储索引，获取 存储空间对象 （m_tlsIndex、CThreadData*）
从 存储空间对象 关联的 内存区块 的指定位置 取出数据 （nSlot, void*）






PROCESS_LOCAL(_AFX_BASE_MODULE_STATE, _afxBaseModuleState)

AFX_COMDAT CProcessLocal<class_name> ident_name;
AFX_COMDAT CProcessLocal<_AFX_BASE_MODULE_STATE> _afxBaseModuleState;



template<class TYPE>
class CProcessLocal
 可视为 CProcessLocalObject 的 包装辅助类。
1.通过模板扩展。
2.提供创建函数。



CProcessLocalObject

m_pObject
设计上用于存储 动态创建的对象 （CNoTrackObject 继承体系）

CNoTrackObject* CProcessLocalObject::GetData(CNoTrackObject* (AFXAPI* pfnCreateObject)())
根据 m_pObject 的值进行操作：
1.如果 m_pObject 为 NULL，则创建对象，并保存由 m_pObject 指向，同时返回该对象。
2.如果 m_pObject 有指向对象，则返回该对象。





CNoTrackObject 
仅是重载 new/delete  （new 调用 LocalAlloc 来分配内存区块，且默认初始化区块为 0）
虚析构 基类






mfc***ud.def


EXPORTS
definitions


definitions is: 
entryname[=internalname] [@ordinal [NONAME]] [PRIVATE] [DATA]


entryname is the function or variable name that you want to export

internalname is the name in the DLL

@ordinal lets you specify that a number, and not the function name, will go into the DLL's export table. 
The .LIB file will contain the mapping between the ordinal and the function, which allows you to use the function name as you normally would in projects that use the DLL. 

The optional NONAME keyword allows you to export by ordinal only and reduce the size of the export table in the resulting DLL. 
However, if you want to use GetProcAddress on the DLL, you must know the ordinal because the name will not be valid. 

The optional keyword PRIVATE prevents entryname from being placed in the import library generated by LINK. 
It has no effect on the export in the image also generated by LINK. 

The optional keyword DATA specifies that an export is data, not code.

When you use PRIVATE and DATA for the same export, PRIVATE must precede DATA. 




.def files [C++], exporting from DLLs

If you need to place the decorated names in the .def file, you can obtain them by using the DUMPBIN tool or by using the linker /MAP option.


dumpbin /SYMBOLS Xappmodul.obj





LIBRARY Win32Proj.dll

EXPORTS
 _WinMain@16=_wWinMain@16 @100 NONAME
 ?AfxWinMain@@YAHPAUHINSTANCE__@@0PA_WH@Z @200 NONAME




Windows 函数

Windows 给出的带有字符串参数的函数都有两个相同版本的函数与之对应，一个是 Unicode 版本，一个是 ANSI 版本，分别以 FunctionNameW 和 FunctionNameA 表示，FunctionName 实际上是一个宏定义。

用户在使用 FunctionNameA 版本的 ANSI 函数时，WIndows 内部会分配一块内存来将 ANSI 字符串转换为 Unicode 字符串，然后再调用 FunctionNameW 版本的 Unicode 函数，
FunctionNameW 返回时，FunctionNameA 将释放申请的内存，又会将 Unicode 字符串转换回 ANSI 字符串。

所以使用 ANSI 版本的例程会有性能损失。

某些 WIndows API 函数没有 Unicode 版本，如 WinExec 和 OpenFile，这些函数的存在是为了和之前的16位程序兼容，现在可以完成抛开这些函数而使用新的其它的 Unicode 函数。

所有 COM 接口方法必须使用 Unicode 字符串，因为 COM 通常用于不同组件之间的通信。

编译器会将所有的资源编译为 Unicode，如果应用程序没有定义 UNICODE 宏，系统会执行内部转换，将 Unicode 资源转换为 ANSI 资源。





C 运行时库函数

同 Windows 函数一样，C 运行时库也有 Unicode 和 ANSI 两个版本的函数，但是不象 Windows 函数，ANSI 版本的函数不会在内部将字符或字符串转换为 Unicode。
C 运行时库使用 _UNICODE 定义 Unicode 宏，常用 C 运行时字符操作库的定义可以参考 tchar.h 文件。








动态库导出 wWinMain
动态库链接时 如何设定使运行时库加载 wWinMain， 而不是 WinMain？


WPRFLAG

crtexe.c

wcrtexe.c 

#define WPRFLAG 1

如何设置使用 wcrtexe.c ？




RawDllMain


AfxTlsAddRef [afxtls_.h] [afxtls.cpp]

AfxCriticalInit [afximpl.h] [afxcrit.cpp]

AfxCriticalTerm [afximpl.h] [afxcrit.cpp]

AfxTlsRelease [afxtls_.h] [afxtls.cpp]






EXPORTS
 _WinMain@16=_wWinMain@16 @100 NONAME
进行 别名 导出，传递的字符串 也是 ASCII 的。说明 仍引用 WinMain。

猜测 主函数 不是由库导出的。
猜测 主函数 是编辑软件自动加的 ( appmodule.cpp )。
将 appmodule.cpp 变更为 Xappmodule.cpp，编译无错。说明不是编辑软件加的。

猜测 如果 主函数 是由库导出的，那么直接 使用工程（WIN32，UNICODE，无 wWinMain）引用 官方的DLL库及LIB库，会是如何？
加入
Atl.lib
atls.lib
atlsd.lib
mfc100.lib
mfc100d.lib
mfc100u.lib
mfc100ud.lib
MFCM100.lib
MFCM100d.lib
MFCM100U.lib
MFCM100Ud.lib
mfcs100.lib
mfcs100d.lib
mfcs100u.lib
mfcs100ud.lib
nafxcw.lib
nafxcwd.lib
uafxcw.lib
uafxcwd.lib

好像没有直接 报有关 链接 主函数 的错误了！！！ 





使用一个WIN32工程， UNICODE 版本，无 wWinMain (等同于 WinMain) 函数，报错总说无 WinMain （ASCII版本），无法编译其引用 wWinMain。   该如何做？
MSVCRTD.lib(crtexew.obj) : error LNK2019: 无法解析的外部符号 _WinMain@16，该符号在函数 ___tmainCRTStartup 中被引用

LOG文件记录链接器信息：
       Link:
         D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\link.exe /ERRORREPORT:PROMPT /OUT:"E:\LZ\work\MyCef2\MyCef2_win32\Debug\Win32Bank.exe" /INCREMENTAL /NOLOGO kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /MANIFEST /ManifestFile:"Debug\Win32Bank.exe.intermediate.manifest" /MANIFESTUAC:"level='asInvoker' uiAccess='false'" /DEBUG /PDB:"E:\LZ\work\MyCef2\MyCef2_win32\Debug\Win32Bank.pdb" /SUBSYSTEM:WINDOWS /TLBID:1 /DYNAMICBASE /NXCOMPAT /IMPLIB:"E:\LZ\work\MyCef2\MyCef2_win32\Debug\Win32Bank.lib" /MACHINE:X86 Debug\Win32Bank.exe.embed.manifest.res
         
工程项目属性默认引用如下库：（LOG文件链接器信息中也可查看确认）
kernel32.lib
user32.lib
gdi32.lib
winspool.lib
comdlg32.lib
advapi32.lib
shell32.lib
ole32.lib
oleaut32.lib
uuid.lib
odbc32.lib
odbccp32.lib




变更工程属性 由 “使用标准 Windows 库” 为 “在共享 DLL 中使用 MFC”

工程文件 *.vcxproj 中的变更内容
<UseOfMfc>Dynamic</UseOfMfc>

编译报错是 wWinMain 了！！！
MSVCRTD.lib(wcrtexew.obj) : error LNK2019: 无法解析的外部符号 _wWinMain@16，该符号在函数 ___tmainCRTStartup 中被引用


日志记录（项目名.log）的编译指令区别：

变更前：
       ClCompile:
         D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\CL.exe /c /ZI /nologo /W3 /WX- /Od /Oy- /D WIN32 /D _DEBUG /D _WINDOWS /D _UNICODE /D UNICODE            /Gm /EHsc /RTC1 /MDd /GS /fp:precise /Zc:wchar_t /Zc:forScope /Fo"Debug\\" /Fd"Debug\vc100.pdb" /Gd /TP /analyze- /errorReport:prompt Main.cpp
变更后：		 
       ClCompile:
         D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\CL.exe /c /ZI /nologo /W3 /WX- /Od /Oy- /D WIN32 /D _DEBUG /D _WINDOWS /D _UNICODE /D UNICODE /D _AFXDLL /Gm /EHsc /RTC1 /MDd /GS /fp:precise /Zc:wchar_t /Zc:forScope /Fo"Debug\\" /Fd"Debug\vc100.pdb" /Gd /TP /analyze- /errorReport:prompt Main.cpp

变更前：
       Link:
         D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\link.exe /ERRORREPORT:PROMPT /OUT:"E:\LZ\test\Win32Proj\Debug\Win32Bank.exe" /INCREMENTAL /NOLOGO kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /MANIFEST /ManifestFile:"Debug\Win32Bank.exe.intermediate.manifest" /MANIFESTUAC:"level='asInvoker' uiAccess='false'" /DEBUG /PDB:"E:\LZ\test\Win32Proj\Debug\Win32Bank.pdb" /SUBSYSTEM:WINDOWS /TLBID:1                             /DYNAMICBASE /NXCOMPAT /IMPLIB:"E:\LZ\test\Win32Proj\Debug\Win32Bank.lib" /MACHINE:X86 Debug\Win32Bank.exe.embed.manifest.res
变更后：
       Link:
         D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\link.exe /ERRORREPORT:PROMPT /OUT:"E:\LZ\test\Win32Proj\Debug\Win32Bank.exe" /INCREMENTAL /NOLOGO                                                                                                                                              /MANIFEST /ManifestFile:"Debug\Win32Bank.exe.intermediate.manifest" /MANIFESTUAC:"level='asInvoker' uiAccess='false'" /DEBUG /PDB:"E:\LZ\test\Win32Proj\Debug\Win32Bank.pdb" /SUBSYSTEM:WINDOWS /TLBID:1 /ENTRY:"wWinMainCRTStartup" /DYNAMICBASE /NXCOMPAT /IMPLIB:"E:\LZ\test\Win32Proj\Debug\Win32Bank.lib" /MACHINE:X86 Debug\Win32Bank.exe.embed.manifest.res
         

/ENTRY:"wWinMainCRTStartup"
工程属性中 没有直接变更这个值的




dumpbin /EXPORTS *.lib
dumpbin /ALL *.lib

mfcs100*.lib
nafxcw*.lib
uafxcw*.lib
都导出有关 WINMAIN 函数




配置属性-》链接器-》常规-》显示进度-》*     中设置
可以设置链接器对LIB库的查找加载顺序。

有结果如下：
             正在搜索 D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\atlmfc\lib\mfcs100ud.lib:
               已找到 _wWinMain@16
                 已在 msvcrtd.lib(wcrtexew.obj) 中引用
                 已加载 mfcs100ud.lib(appmodul.obj)






win32程序中,使用MFC库
1.在项目属性->配置属性->常规->MFC的使用,选择"在共享DLL中使用MFC"

2.////Note:用于隐藏掉console框    《工程属性中也可以设置》
#pragma comment(linker, "/subsystem:/"windows/" /entry:/"mainCRTStartup/"" ) // 设置入口地址 

3.添加include文件afxwin.h
#include <afxwin.h>


.def 文件的注释是使用 “;” ， 在语句前。

（动态、静态）库是UNICODE版本。则 主程（EXE） 指定 /ENTRY:"wWinMainCRTStartup" 可以 调用 UNICODE 版本的 入口函数 （ 如 wWinMain ）












C 转义符 ASCII



.c中变量必须定义在执行语句前面

C98中规定，所有的局部变量必须定义在每个块的开头。

C99以及C++中则没有这个限制，即在首次使用之前，可以在块的任何位置声明变量。







CMAKE 运行后，生成的 CMakeCache.txt 中保存了 “变量：值” 数据。



将make的输出重定向到文件

所有的信息都输出到同一个文件中：
make xxx > build_output_all.txt 2>&1
其中的2>&1表示错误信息输出到&1中，而&1，指的是前面的那个文件：build_output_all.txt 。
注意：上面所有的1,2等数字，后面紧跟着大于号'>' ，中间不能有空格






..\..\..\..\..\..\third_party\cef\cef_binary_3.3538.1852.gcb937fc_windows32\Release\libcef.lib
..\..\..\..\..\libcef_dll_wrapper\Release\libcef_dll_wrapper.lib
comctl32.lib
rpcrt4.lib
shlwapi.lib
ws2_32.lib
kernel32.lib
user32.lib
gdi32.lib
winspool.lib
shell32.lib
ole32.lib
oleaut32.lib
uuid.lib
comdlg32.lib
advapi32.lib


libcef.lib
libcef_dll_wrapper.lib
comctl32.lib
rpcrt4.lib
shlwapi.lib
ws2_32.lib
kernel32.lib
user32.lib
gdi32.lib
winspool.lib
shell32.lib
ole32.lib
oleaut32.lib
uuid.lib
comdlg32.lib
advapi32.lib


msvcprtd.lib(MSVCP100D.dll) : error LNK2005

解决办法：
工程(Project)->属性(Properties)->配置属性(Configuration Properties)->c/c++->代码生成(Code Generation)->运行时库(Use run-time library)->多线程调试DLL(/MDd)(Multithreaded DLL/Debug Multithreaded DLL)
编译库的工程和自己当前开发的工程，都要使用同样的设置。也就是json对应的.lib文件是分模式（Debug或Release）的，两种编译模式在两个工程配置中需要保持一致。

如果两种模式的工程配置是一致的但是还是无法解决，就需要忽略出问题的库文件了。方法如下：
工程(Project)->属性(Properties)->配置属性(Configuration Properties)->链接器->输入->忽略特定库中添加重定义的库文件，这里是msvcprtd.lib和LIBCMTD.lib。


D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\link.exe /ERRORREPORT:PROMPT /OUT:"E:\LZ\work\MyCef\CEFwin32\Debug\CEFwin32.exe" /INCREMENTAL /NOLOGO libcef.lib libcef_dll_wrapper.lib comctl32.lib rpcrt4.lib shlwapi.lib ws2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib shell32.lib ole32.lib oleaut32.lib uuid.lib comdlg32.lib advapi32.lib /MANIFEST /ManifestFile:"Debug\CEFwin32.exe.intermediate.manifest" /MANIFESTUAC:"level='asInvoker' uiAccess='false'" /DEBUG /PDB:"E:\LZ\work\MyCef\CEFwin32\Debug\CEFwin32.pdb" /SUBSYSTEM:WINDOWS /TLBID:1 /DYNAMICBASE /NXCOMPAT /IMPLIB:"E:\LZ\work\MyCef\CEFwin32\Debug\CEFwin32.lib" /MACHINE:X86 Debug\CEFwin32.exe.embed.manifest.res
D:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\link.exe /ERRORREPORT:PROMPT /OUT:"E:\LZ\work\MyCef\CEFwin32\Debug\CEFwin32.exe" /INCREMENTAL /NOLOGO libcef.lib libcef_dll_wrapper.lib comctl32.lib rpcrt4.lib shlwapi.lib ws2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib shell32.lib ole32.lib oleaut32.lib uuid.lib comdlg32.lib advapi32.lib /MANIFEST /ManifestFile:"Debug\CEFwin32.exe.intermediate.manifest" /MANIFESTUAC:"level='asInvoker' uiAccess='false'" /DEBUG /PDB:"E:\LZ\work\MyCef\CEFwin32\Debug\CEFwin32.pdb" /SUBSYSTEM:WINDOWS /TLBID:1 /DYNAMICBASE /NXCOMPAT /IMPLIB:"E:\LZ\work\MyCef\CEFwin32\Debug\CEFwin32.lib" /MACHINE:X86 Debug\CEFwin32.exe.embed.manifest.res


/OUT:"E:\LZ\work\cef-project\build\third_party\cef\cef_binary_3.3538.1852.gcb937fc_windows32\tests\cefsimple\Debug\cefsimple.exe" /INCREMENTAL /NOLOGO "..\..\..\..\..\..\third_party\cef\cef_binary_3.3538.1852.gcb937fc_windows32\Debug\libcef.lib" "..\..\..\..\..\libcef_dll_wrapper\Debug\libcef_dll_wrapper.lib" "comctl32.lib" "rpcrt4.lib" "shlwapi.lib" "ws2_32.lib" "kernel32.lib" "user32.lib" "gdi32.lib" "winspool.lib" "shell32.lib" "ole32.lib" "oleaut32.lib" "uuid.lib" "comdlg32.lib" "advapi32.lib" /MANIFEST:NO /ManifestFile:"cefsimple.dir\Debug\cefsimple.exe.intermediate.manifest" /ALLOWISOLATION /MANIFESTUAC:"level='asInvoker' uiAccess='false'" /DEBUG /PDB:"E:/LZ/work/cef-project/build/third_party/cef/cef_binary_3.3538.1852.gcb937fc_windows32/tests/cefsimple/Debug/cefsimple.pdb" /SUBSYSTEM:WINDOWS /LARGEADDRESSAWARE /PGD:"E:\LZ\work\cef-project\build\third_party\cef\cef_binary_3.3538.1852.gcb937fc_windows32\tests\cefsimple\Debug\cefsimple.pgd" /TLBID:1 /DYNAMICBASE /NXCOMPAT /IMPLIB:"E:/LZ/work/cef-project/build/third_party/cef/cef_binary_3.3538.1852.gcb937fc_windows32/tests/cefsimple/Debug/cefsimple.lib" /MACHINE:X86 /ERRORREPORT:QUEUE 

/OUT:"E:\LZ\work\MyCef\CEFwin32\Debug\CEFwin32.exe"                                                                               /INCREMENTAL /NOLOGO                                                                                   "libcef.lib"                                         "libcef_dll_wrapper.lib" "comctl32.lib" "rpcrt4.lib" "shlwapi.lib" "ws2_32.lib" "kernel32.lib" "user32.lib" "gdi32.lib" "winspool.lib" "shell32.lib" "ole32.lib" "oleaut32.lib" "uuid.lib" "comdlg32.lib" "advapi32.lib" /MANIFEST    /ManifestFile:"Debug\CEFwin32.exe.intermediate.manifest"                /ALLOWISOLATION /MANIFESTUAC:"level='asInvoker' uiAccess='false'" /DEBUG /PDB:"E:\LZ\work\MyCef\CEFwin32\Debug\CEFwin32.pdb"                                                                               /SUBSYSTEM:WINDOWS                    /PGD:"E:\LZ\work\MyCef\CEFwin32\Debug\CEFwin32.pgd"                                                                               /TLBID:1 /DYNAMICBASE /NXCOMPAT                                                                                                                                      /MACHINE:X86 /ERRORREPORT:QUEUE 
/OUT:"E:\LZ\work\MyCef\CEFwin32\Debug\CEFwin32.exe"                                                                               /INCREMENTAL /NOLOGO                                                                                   "libcef.lib"                                         "libcef_dll_wrapper.lib" "comctl32.lib" "rpcrt4.lib" "shlwapi.lib" "ws2_32.lib" "kernel32.lib" "user32.lib" "gdi32.lib" "winspool.lib" "shell32.lib" "ole32.lib" "oleaut32.lib" "uuid.lib" "comdlg32.lib" "advapi32.lib" /MANIFEST:NO /ManifestFile:"Debug\CEFwin32.exe.intermediate.manifest"                /ALLOWISOLATION /MANIFESTUAC:"level='asInvoker' uiAccess='false'" /DEBUG /PDB:"E:\LZ\work\MyCef\CEFwin32\Debug\CEFwin32.pdb"                                                                               /SUBSYSTEM:WINDOWS /LARGEADDRESSAWARE /PGD:"E:\LZ\work\MyCef\CEFwin32\Debug\CEFwin32.pgd"                                                                               /TLBID:1 /DYNAMICBASE /NXCOMPAT                                                                                                                                      /MACHINE:X86 /ERRORREPORT:QUEUE 
/OUT:"E:\LZ\work\MyCef\CEFwin32\Debug\CEFwin32.exe"                                                                               /INCREMENTAL /NOLOGO                                                                                   "libcef.lib"                                         "libcef_dll_wrapper.lib" "comctl32.lib" "rpcrt4.lib" "shlwapi.lib" "ws2_32.lib" "kernel32.lib" "user32.lib" "gdi32.lib" "winspool.lib" "shell32.lib" "ole32.lib" "oleaut32.lib" "uuid.lib" "comdlg32.lib" "advapi32.lib" /MANIFEST:NO /ManifestFile:"Debug\CEFwin32.exe.intermediate.manifest"                /ALLOWISOLATION /MANIFESTUAC:"level='asInvoker' uiAccess='false'" /DEBUG /PDB:"E:\LZ\work\MyCef\CEFwin32\Debug\CEFwin32.pdb"                                                                               /SUBSYSTEM:WINDOWS /LARGEADDRESSAWARE /PGD:"E:\LZ\work\MyCef\CEFwin32\Debug\CEFwin32.pgd"                                                                               /TLBID:1 /DYNAMICBASE /NXCOMPAT /IMPLIB:"E:\LZ\work\MyCef\CEFwin32\Debug\CEFwin32.lib"                                                                               /MACHINE:X86 /ERRORREPORT:QUEUE 

主要是将【运行库】 “多线程调试 DLL (/MDd)” 更改为 “多线程调试 (/MTd)”


由此推断CEF是使用的静态库


















